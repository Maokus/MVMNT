// Animation utilities: basic math helpers and FloatCurve class for keyed float interpolation.
// Author: autogenerated by AI assistant

import easings from '@animation/easing';

// Basic math helpers
export const clamp = (v: number, min: number, max: number) => (v < min ? min : v > max ? max : v);
export const lerp = (a: number, b: number, t: number) => a + (b - a) * t;
export const invLerp = (a: number, b: number, v: number) => (b - a === 0 ? 0 : (v - a) / (b - a));
export const remap = (inMin: number, inMax: number, outMin: number, outMax: number, v: number) =>
    lerp(outMin, outMax, clamp(invLerp(inMin, inMax, v), 0, 1));

export type EasingFn = (t: number) => number;

export interface FloatCurvePoint {
    factor: number; // x in [0,1]
    value: number; // y value
    easeToNext: EasingFn; // easing function to next point
}

/**
 * FloatCurve provides interpolation of values along a normalized 0..1 factor domain.
 * Points may be sparse; constructor patches implicit 0 and 1 boundary points if absent.
 */
export class FloatCurve {
    private points: FloatCurvePoint[];

    constructor(rawPoints: Array<[number, number, EasingFn?]>) {
        if (!rawPoints || rawPoints.length === 0) {
            // default straight line 0->1
            this.points = [
                { factor: 0, value: 0, easeToNext: easings.linear },
                { factor: 1, value: 1, easeToNext: easings.linear },
            ];
            return;
        }

        // Map input to structured points; default easing is linear
        const mapped: FloatCurvePoint[] = rawPoints.map(([factor, value, ease]) => ({
            factor: clamp(factor, 0, 1),
            value,
            easeToNext: ease || easings.linear,
        }));

        // Sort by factor
        mapped.sort((a, b) => a.factor - b.factor);

        // Inject first boundary if needed
        if (mapped[0].factor > 0) {
            mapped.unshift({ factor: 0, value: 0, easeToNext: easings.linear });
        }
        // Inject last boundary if needed
        const last = mapped[mapped.length - 1];
        if (last.factor < 1) {
            mapped.push({ factor: 1, value: last.value, easeToNext: easings.linear });
        } else if (last.factor === 1) {
            // ensure last easing not used (not strictly needed)
            last.easeToNext = easings.linear;
        }

        // Collapse duplicates (keeping the latest value/ease for same factor, but ensuring order)
        const dedup: FloatCurvePoint[] = [];
        for (const p of mapped) {
            const prev = dedup[dedup.length - 1];
            if (prev && Math.abs(prev.factor - p.factor) < 1e-6) {
                // replace previous
                prev.value = p.value;
                prev.easeToNext = p.easeToNext;
            } else {
                dedup.push(p);
            }
        }

        this.points = dedup;
    }

    /** Return value at factor in [0,1] (clamped). */
    valAt(factor: number): number {
        if (this.points.length === 1) return this.points[0].value;
        const f = clamp(factor, 0, 1);
        // Find segment via linear scan (small point counts expected). Could binary search if large.
        for (let i = 0; i < this.points.length - 1; i++) {
            const a = this.points[i];
            const b = this.points[i + 1];
            if (f >= a.factor && f <= b.factor) {
                const span = b.factor - a.factor;
                if (span <= 1e-9) return b.value; // degenerate
                const localT = (f - a.factor) / span;
                const easedT = a.easeToNext(clamp(localT, 0, 1));
                return lerp(a.value, b.value, easedT);
            }
        }
        // Fallback (shouldn't hit): return last value
        return this.points[this.points.length - 1].value;
    }

    /** Get raw points (defensive copy) */
    getPoints(): FloatCurvePoint[] {
        return this.points.map((p) => ({ ...p }));
    }
}

export const AnimMath = { clamp, lerp, invLerp, remap };

export default {
    FloatCurve,
    clamp,
    lerp,
    invLerp,
    remap,
};
